// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

using System.Text.Json.Serialization;

namespace FBS.RtpStream
{

    using global::System;
    using global::System.Collections.Generic;
    using global::Google.FlatBuffers;

    public struct Params : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_2_10(); }
        public static Params GetRootAsParams(ByteBuffer _bb) { return GetRootAsParams(_bb, new Params()); }
        public static Params GetRootAsParams(ByteBuffer _bb, Params obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
        public Params __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public uint EncodingIdx { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
        public uint Ssrc { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
        public byte PayloadType { get { int o = __p.__offset(8); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
        public string MimeType { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetMimeTypeBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
        public ArraySegment<byte>? GetMimeTypeBytes() { return __p.__vector_as_arraysegment(10); }
#endif
        public byte[] GetMimeTypeArray() { return __p.__vector_as_array<byte>(10); }
        public uint ClockRate { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
        public string Rid { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetRidBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
        public ArraySegment<byte>? GetRidBytes() { return __p.__vector_as_arraysegment(14); }
#endif
        public byte[] GetRidArray() { return __p.__vector_as_array<byte>(14); }
        public string Cname { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCnameBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
        public ArraySegment<byte>? GetCnameBytes() { return __p.__vector_as_arraysegment(16); }
#endif
        public byte[] GetCnameArray() { return __p.__vector_as_array<byte>(16); }
        public uint? RtxSsrc { get { int o = __p.__offset(18); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint?)null; } }
        public byte? RtxPayloadType { get { int o = __p.__offset(20); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte?)null; } }
        public bool UseNack { get { int o = __p.__offset(22); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public bool UsePli { get { int o = __p.__offset(24); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public bool UseFir { get { int o = __p.__offset(26); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public bool UseInBandFec { get { int o = __p.__offset(28); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public bool UseDtx { get { int o = __p.__offset(30); return o != 0 ? 0 != __p.bb.Get(o + __p.bb_pos) : (bool)false; } }
        public byte SpatialLayers { get { int o = __p.__offset(32); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }
        public byte TemporalLayers { get { int o = __p.__offset(34); return o != 0 ? __p.bb.Get(o + __p.bb_pos) : (byte)0; } }

        public static Offset<FBS.RtpStream.Params> CreateParams(FlatBufferBuilder builder,
            uint encoding_idx = 0,
            uint ssrc = 0,
            byte payload_type = 0,
            StringOffset mime_typeOffset = default(StringOffset),
            uint clock_rate = 0,
            StringOffset ridOffset = default(StringOffset),
            StringOffset cnameOffset = default(StringOffset),
            uint? rtx_ssrc = null,
            byte? rtx_payload_type = null,
            bool use_nack = false,
            bool use_pli = false,
            bool use_fir = false,
            bool use_in_band_fec = false,
            bool use_dtx = false,
            byte spatial_layers = 0,
            byte temporal_layers = 0)
        {
            builder.StartTable(16);
            Params.AddRtxSsrc(builder, rtx_ssrc);
            Params.AddCname(builder, cnameOffset);
            Params.AddRid(builder, ridOffset);
            Params.AddClockRate(builder, clock_rate);
            Params.AddMimeType(builder, mime_typeOffset);
            Params.AddSsrc(builder, ssrc);
            Params.AddEncodingIdx(builder, encoding_idx);
            Params.AddTemporalLayers(builder, temporal_layers);
            Params.AddSpatialLayers(builder, spatial_layers);
            Params.AddUseDtx(builder, use_dtx);
            Params.AddUseInBandFec(builder, use_in_band_fec);
            Params.AddUseFir(builder, use_fir);
            Params.AddUsePli(builder, use_pli);
            Params.AddUseNack(builder, use_nack);
            Params.AddRtxPayloadType(builder, rtx_payload_type);
            Params.AddPayloadType(builder, payload_type);
            return Params.EndParams(builder);
        }

        public static void StartParams(FlatBufferBuilder builder) { builder.StartTable(16); }
        public static void AddEncodingIdx(FlatBufferBuilder builder, uint encodingIdx) { builder.AddUint(0, encodingIdx, 0); }
        public static void AddSsrc(FlatBufferBuilder builder, uint ssrc) { builder.AddUint(1, ssrc, 0); }
        public static void AddPayloadType(FlatBufferBuilder builder, byte payloadType) { builder.AddByte(2, payloadType, 0); }
        public static void AddMimeType(FlatBufferBuilder builder, StringOffset mimeTypeOffset) { builder.AddOffset(3, mimeTypeOffset.Value, 0); }
        public static void AddClockRate(FlatBufferBuilder builder, uint clockRate) { builder.AddUint(4, clockRate, 0); }
        public static void AddRid(FlatBufferBuilder builder, StringOffset ridOffset) { builder.AddOffset(5, ridOffset.Value, 0); }
        public static void AddCname(FlatBufferBuilder builder, StringOffset cnameOffset) { builder.AddOffset(6, cnameOffset.Value, 0); }
        public static void AddRtxSsrc(FlatBufferBuilder builder, uint? rtxSsrc) { builder.AddUint(7, rtxSsrc); }
        public static void AddRtxPayloadType(FlatBufferBuilder builder, byte? rtxPayloadType) { builder.AddByte(8, rtxPayloadType); }
        public static void AddUseNack(FlatBufferBuilder builder, bool useNack) { builder.AddBool(9, useNack, false); }
        public static void AddUsePli(FlatBufferBuilder builder, bool usePli) { builder.AddBool(10, usePli, false); }
        public static void AddUseFir(FlatBufferBuilder builder, bool useFir) { builder.AddBool(11, useFir, false); }
        public static void AddUseInBandFec(FlatBufferBuilder builder, bool useInBandFec) { builder.AddBool(12, useInBandFec, false); }
        public static void AddUseDtx(FlatBufferBuilder builder, bool useDtx) { builder.AddBool(13, useDtx, false); }
        public static void AddSpatialLayers(FlatBufferBuilder builder, byte spatialLayers) { builder.AddByte(14, spatialLayers, 0); }
        public static void AddTemporalLayers(FlatBufferBuilder builder, byte temporalLayers) { builder.AddByte(15, temporalLayers, 0); }
        public static Offset<FBS.RtpStream.Params> EndParams(FlatBufferBuilder builder)
        {
            int o = builder.EndTable();
            builder.Required(o, 10);  // mime_type
            builder.Required(o, 16);  // cname
            return new Offset<FBS.RtpStream.Params>(o);
        }
        public ParamsT UnPack()
        {
            var _o = new ParamsT();
            this.UnPackTo(_o);
            return _o;
        }
        public void UnPackTo(ParamsT _o)
        {
            _o.EncodingIdx = this.EncodingIdx;
            _o.Ssrc = this.Ssrc;
            _o.PayloadType = this.PayloadType;
            _o.MimeType = this.MimeType;
            _o.ClockRate = this.ClockRate;
            _o.Rid = this.Rid;
            _o.Cname = this.Cname;
            _o.RtxSsrc = this.RtxSsrc;
            _o.RtxPayloadType = this.RtxPayloadType;
            _o.UseNack = this.UseNack;
            _o.UsePli = this.UsePli;
            _o.UseFir = this.UseFir;
            _o.UseInBandFec = this.UseInBandFec;
            _o.UseDtx = this.UseDtx;
            _o.SpatialLayers = this.SpatialLayers;
            _o.TemporalLayers = this.TemporalLayers;
        }
        public static Offset<FBS.RtpStream.Params> Pack(FlatBufferBuilder builder, ParamsT _o)
        {
            if(_o == null)
                return default(Offset<FBS.RtpStream.Params>);
            var _mime_type = _o.MimeType == null ? default(StringOffset) : builder.CreateString(_o.MimeType);
            var _rid = _o.Rid == null ? default(StringOffset) : builder.CreateString(_o.Rid);
            var _cname = _o.Cname == null ? default(StringOffset) : builder.CreateString(_o.Cname);
            return CreateParams(
              builder,
              _o.EncodingIdx,
              _o.Ssrc,
              _o.PayloadType,
              _mime_type,
              _o.ClockRate,
              _rid,
              _cname,
              _o.RtxSsrc,
              _o.RtxPayloadType,
              _o.UseNack,
              _o.UsePli,
              _o.UseFir,
              _o.UseInBandFec,
              _o.UseDtx,
              _o.SpatialLayers,
              _o.TemporalLayers);
        }
    }

    public class ParamsT
    {
        public uint EncodingIdx { get; set; }

        public uint Ssrc { get; set; }

        public byte PayloadType { get; set; }

        public string MimeType { get; set; }

        public uint ClockRate { get; set; }

        public string Rid { get; set; }

        public string Cname { get; set; }

        public uint? RtxSsrc { get; set; }

        public byte? RtxPayloadType { get; set; }

        public bool UseNack { get; set; }

        public bool UsePli { get; set; }

        public bool UseFir { get; set; }

        public bool UseInBandFec { get; set; }

        public bool UseDtx { get; set; }

        public byte SpatialLayers { get; set; }

        public byte TemporalLayers { get; set; }

        public ParamsT()
        {
            this.EncodingIdx = 0;
            this.Ssrc = 0;
            this.PayloadType = 0;
            this.MimeType = null;
            this.ClockRate = 0;
            this.Rid = null;
            this.Cname = null;
            this.RtxSsrc = null;
            this.RtxPayloadType = null;
            this.UseNack = false;
            this.UsePli = false;
            this.UseFir = false;
            this.UseInBandFec = false;
            this.UseDtx = false;
            this.SpatialLayers = 0;
            this.TemporalLayers = 0;
        }
    }


    static public class ParamsVerify
    {
        static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
        {
            return verifier.VerifyTableStart(tablePos)
              && verifier.VerifyField(tablePos, 4 /*EncodingIdx*/, 4 /*uint*/, 4, false)
              && verifier.VerifyField(tablePos, 6 /*Ssrc*/, 4 /*uint*/, 4, false)
              && verifier.VerifyField(tablePos, 8 /*PayloadType*/, 1 /*byte*/, 1, false)
              && verifier.VerifyString(tablePos, 10 /*MimeType*/, true)
              && verifier.VerifyField(tablePos, 12 /*ClockRate*/, 4 /*uint*/, 4, false)
              && verifier.VerifyString(tablePos, 14 /*Rid*/, false)
              && verifier.VerifyString(tablePos, 16 /*Cname*/, true)
              && verifier.VerifyField(tablePos, 18 /*RtxSsrc*/, 4 /*uint*/, 4, false)
              && verifier.VerifyField(tablePos, 20 /*RtxPayloadType*/, 1 /*byte*/, 1, false)
              && verifier.VerifyField(tablePos, 22 /*UseNack*/, 1 /*bool*/, 1, false)
              && verifier.VerifyField(tablePos, 24 /*UsePli*/, 1 /*bool*/, 1, false)
              && verifier.VerifyField(tablePos, 26 /*UseFir*/, 1 /*bool*/, 1, false)
              && verifier.VerifyField(tablePos, 28 /*UseInBandFec*/, 1 /*bool*/, 1, false)
              && verifier.VerifyField(tablePos, 30 /*UseDtx*/, 1 /*bool*/, 1, false)
              && verifier.VerifyField(tablePos, 32 /*SpatialLayers*/, 1 /*byte*/, 1, false)
              && verifier.VerifyField(tablePos, 34 /*TemporalLayers*/, 1 /*byte*/, 1, false)
              && verifier.VerifyTableEnd(tablePos);
        }
    }

}
